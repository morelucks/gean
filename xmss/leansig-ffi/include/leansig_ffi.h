/*
 * leansig_ffi.h - Auto-generated C header for the leansig FFI library.
 *
 * DO NOT EDIT MANUALLY. This file is generated by cbindgen from src/lib.rs.
 * Run `cargo build` to regenerate.
 *
 * This header provides a C-compatible interface to the leansig XMSS
 * post-quantum signature scheme (devnet-1 instantiation).
 *
 * Memory management: Every allocated object has a corresponding _free function.
 * Byte buffers returned by serialize/sign must be freed with
 * leansig_bytes_free.
 */

#ifndef LEANSIG_FFI_H
#define LEANSIG_FFI_H

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
/* Message length expected by sign/verify (XMSS signs 32-byte messages). */
#define LEANSIG_MESSAGE_LENGTH 32

// Result codes returned by FFI functions.
typedef enum LeansigResult {
  // Operation succeeded.
  LEANSIG_RESULT_OK = 0,
  // Null pointer argument.
  LEANSIG_RESULT_NULL_POINTER = 1,
  // Invalid buffer length.
  LEANSIG_RESULT_INVALID_LENGTH = 2,
  // Signing failed (encoding attempts exceeded).
  LEANSIG_RESULT_SIGNING_FAILED = 3,
  // Deserialization (from_bytes) failed.
  LEANSIG_RESULT_DESERIALIZATION_FAILED = 4,
  // Signature verification failed.
  LEANSIG_RESULT_VERIFICATION_FAILED = 5,
  // Epoch outside prepared interval.
  LEANSIG_RESULT_EPOCH_NOT_PREPARED = 6,
} LeansigResult;

// Opaque keypair holding both public and secret keys.
typedef struct LeansigKeypair LeansigKeypair;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Generate a new XMSS keypair.
//
// # Arguments
// * `seed` - Random seed for the RNG (will be used to seed a SmallRng).
// * `activation_epoch` - Starting epoch for which the key is active.
// * `num_active_epochs` - Number of consecutive active epochs.
// * `out_keypair` - Pointer to receive the opaque keypair handle.
//
// # Returns
// `LeansigResult::Ok` on success.
//
// # Note
// Key generation is performed on a dedicated thread with a large stack
// (64 MB) to accommodate the deep recursion required by XMSS Merkle tree
// construction with LOG_LIFETIME=32.
enum LeansigResult leansig_keypair_generate(uint64_t seed,
                                            uint64_t activation_epoch,
                                            uint64_t num_active_epochs,
                                            struct LeansigKeypair **out_keypair);

// Restore a keypair from serialized public and secret key bytes.
//
// # Arguments
// * `pk_bytes` - Pointer to the serialized public key bytes.
// * `pk_len` - Length of the public key bytes.
// * `sk_bytes` - Pointer to the serialized secret key bytes.
// * `sk_len` - Length of the secret key bytes.
// * `out_keypair` - Pointer to receive the opaque keypair handle.
//
// # Returns
// `LeansigResult::Ok` on success, or `DeserializationFailed` if bytes are invalid.
enum LeansigResult leansig_keypair_restore(const uint8_t *pk_bytes,
                                           size_t pk_len,
                                           const uint8_t *sk_bytes,
                                           size_t sk_len,
                                           struct LeansigKeypair **out_keypair);

// Free a keypair allocated by `leansig_keypair_generate`.
void leansig_keypair_free(struct LeansigKeypair *keypair);

// Get the SSZ-serialized public key from a keypair.
//
// The caller must free the returned buffer with `leansig_bytes_free`.
//
// # Arguments
// * `keypair` - Opaque keypair handle.
// * `out_data` - Pointer to receive the byte buffer.
// * `out_len` - Pointer to receive the buffer length.
enum LeansigResult leansig_pubkey_serialize(const struct LeansigKeypair *keypair,
                                            uint8_t **out_data,
                                            size_t *out_len);

// Get the SSZ-serialized secret key from a keypair.
//
// The caller must free the returned buffer with `leansig_bytes_free`.
enum LeansigResult leansig_seckey_serialize(const struct LeansigKeypair *keypair,
                                            uint8_t **out_data,
                                            size_t *out_len);

// Free a byte buffer returned by any `leansig_*_serialize` function.
void leansig_bytes_free(uint8_t *data, size_t len);

// Get the start of the activation interval for this secret key.
uint64_t leansig_sk_activation_start(const struct LeansigKeypair *keypair);

// Get the end (exclusive) of the activation interval for this secret key.
uint64_t leansig_sk_activation_end(const struct LeansigKeypair *keypair);

// Get the start of the currently prepared interval.
uint64_t leansig_sk_prepared_start(const struct LeansigKeypair *keypair);

// Get the end (exclusive) of the currently prepared interval.
uint64_t leansig_sk_prepared_end(const struct LeansigKeypair *keypair);

// Advance the secret key's prepared interval to the next window.
enum LeansigResult leansig_sk_advance_preparation(struct LeansigKeypair *keypair);

// Sign a 32-byte message at a given epoch.
//
// The caller must free the returned signature buffer with `leansig_bytes_free`.
//
// # Arguments
// * `keypair` - Opaque keypair handle (secret key is used).
// * `epoch` - The epoch to sign at (must be in the prepared interval).
// * `message` - Pointer to 32-byte message.
// * `out_sig_data` - Pointer to receive the SSZ-serialized signature bytes.
// * `out_sig_len` - Pointer to receive the signature length.
enum LeansigResult leansig_sign(const struct LeansigKeypair *keypair,
                                uint32_t epoch,
                                const uint8_t *message,
                                uint8_t **out_sig_data,
                                size_t *out_sig_len);

// Verify a signature against a public key, epoch, and message.
//
// # Arguments
// * `pk_data` - SSZ-serialized public key bytes.
// * `pk_len` - Length of public key bytes.
// * `epoch` - The epoch the signature was created at.
// * `message` - Pointer to 32-byte message.
// * `sig_data` - SSZ-serialized signature bytes.
// * `sig_len` - Length of signature bytes.
//
// # Returns
// `LeansigResult::Ok` if verification succeeds, `LeansigResult::VerificationFailed` otherwise.
enum LeansigResult leansig_verify(const uint8_t *pk_data,
                                  size_t pk_len,
                                  uint32_t epoch,
                                  const uint8_t *message,
                                  const uint8_t *sig_data,
                                  size_t sig_len);

// Verify a signature using the public key from a keypair handle.
//
// Convenience wrapper that avoids serialization/deserialization of the public key.
enum LeansigResult leansig_verify_with_keypair(const struct LeansigKeypair *keypair,
                                               uint32_t epoch,
                                               const uint8_t *message,
                                               const uint8_t *sig_data,
                                               size_t sig_len);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* LEANSIG_FFI_H */
