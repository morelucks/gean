// Code generated by fastssz. DO NOT EDIT.
// Hash: f1c8ae74e2c8761ac626a30e1bd49fc8a508740119be7be1ad05641470e28f56
// Version: 0.1.3
package types

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Checkpoint object
func (c *Checkpoint) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Checkpoint object to a target array
func (c *Checkpoint) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Root'
	dst = append(dst, c.Root[:]...)

	// Field (1) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(c.Slot))

	return
}

// UnmarshalSSZ ssz unmarshals the Checkpoint object
func (c *Checkpoint) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 40 {
		return ssz.ErrSize
	}

	// Field (0) 'Root'
	copy(c.Root[:], buf[0:32])

	// Field (1) 'Slot'
	c.Slot = Slot(ssz.UnmarshallUint64(buf[32:40]))

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Checkpoint object
func (c *Checkpoint) SizeSSZ() (size int) {
	size = 40
	return
}

// HashTreeRoot ssz hashes the Checkpoint object
func (c *Checkpoint) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Checkpoint object with a hasher
func (c *Checkpoint) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Root'
	hh.PutBytes(c.Root[:])

	// Field (1) 'Slot'
	hh.PutUint64(uint64(c.Slot))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Checkpoint object
func (c *Checkpoint) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the Config object
func (c *Config) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Config object to a target array
func (c *Config) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'NumValidators'
	dst = ssz.MarshalUint64(dst, c.NumValidators)

	// Field (1) 'GenesisTime'
	dst = ssz.MarshalUint64(dst, c.GenesisTime)

	return
}

// UnmarshalSSZ ssz unmarshals the Config object
func (c *Config) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 16 {
		return ssz.ErrSize
	}

	// Field (0) 'NumValidators'
	c.NumValidators = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'GenesisTime'
	c.GenesisTime = ssz.UnmarshallUint64(buf[8:16])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Config object
func (c *Config) SizeSSZ() (size int) {
	size = 16
	return
}

// HashTreeRoot ssz hashes the Config object
func (c *Config) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Config object with a hasher
func (c *Config) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'NumValidators'
	hh.PutUint64(c.NumValidators)

	// Field (1) 'GenesisTime'
	hh.PutUint64(c.GenesisTime)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Config object
func (c *Config) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the Vote object
func (v *Vote) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the Vote object to a target array
func (v *Vote) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'ValidatorID'
	dst = ssz.MarshalUint64(dst, v.ValidatorID)

	// Field (1) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(v.Slot))

	// Field (2) 'Head'
	if dst, err = v.Head.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (3) 'Target'
	if dst, err = v.Target.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'Source'
	if dst, err = v.Source.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Vote object
func (v *Vote) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 136 {
		return ssz.ErrSize
	}

	// Field (0) 'ValidatorID'
	v.ValidatorID = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Slot'
	v.Slot = Slot(ssz.UnmarshallUint64(buf[8:16]))

	// Field (2) 'Head'
	if err = v.Head.UnmarshalSSZ(buf[16:56]); err != nil {
		return err
	}

	// Field (3) 'Target'
	if err = v.Target.UnmarshalSSZ(buf[56:96]); err != nil {
		return err
	}

	// Field (4) 'Source'
	if err = v.Source.UnmarshalSSZ(buf[96:136]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Vote object
func (v *Vote) SizeSSZ() (size int) {
	size = 136
	return
}

// HashTreeRoot ssz hashes the Vote object
func (v *Vote) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the Vote object with a hasher
func (v *Vote) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidatorID'
	hh.PutUint64(v.ValidatorID)

	// Field (1) 'Slot'
	hh.PutUint64(uint64(v.Slot))

	// Field (2) 'Head'
	if err = v.Head.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (3) 'Target'
	if err = v.Target.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'Source'
	if err = v.Source.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Vote object
func (v *Vote) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the SignedVote object
func (s *SignedVote) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedVote object to a target array
func (s *SignedVote) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Data'
	if dst, err = s.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedVote object
func (s *SignedVote) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 168 {
		return ssz.ErrSize
	}

	// Field (0) 'Data'
	if err = s.Data.UnmarshalSSZ(buf[0:136]); err != nil {
		return err
	}

	// Field (1) 'Signature'
	copy(s.Signature[:], buf[136:168])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedVote object
func (s *SignedVote) SizeSSZ() (size int) {
	size = 168
	return
}

// HashTreeRoot ssz hashes the SignedVote object
func (s *SignedVote) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedVote object with a hasher
func (s *SignedVote) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Data'
	if err = s.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedVote object
func (s *SignedVote) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the BlockHeader object
func (b *BlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockHeader object to a target array
func (b *BlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalUint64(dst, b.ProposerIndex)

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	// Field (3) 'StateRoot'
	dst = append(dst, b.StateRoot[:]...)

	// Field (4) 'BodyRoot'
	dst = append(dst, b.BodyRoot[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockHeader object
func (b *BlockHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 112 {
		return ssz.ErrSize
	}

	// Field (0) 'Slot'
	b.Slot = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'ProposerIndex'
	b.ProposerIndex = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'ParentRoot'
	copy(b.ParentRoot[:], buf[16:48])

	// Field (3) 'StateRoot'
	copy(b.StateRoot[:], buf[48:80])

	// Field (4) 'BodyRoot'
	copy(b.BodyRoot[:], buf[80:112])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockHeader object
func (b *BlockHeader) SizeSSZ() (size int) {
	size = 112
	return
}

// HashTreeRoot ssz hashes the BlockHeader object
func (b *BlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockHeader object with a hasher
func (b *BlockHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(b.ProposerIndex)

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'StateRoot'
	hh.PutBytes(b.StateRoot[:])

	// Field (4) 'BodyRoot'
	hh.PutBytes(b.BodyRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockHeader object
func (b *BlockHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BlockBody object
func (b *BlockBody) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockBody object to a target array
func (b *BlockBody) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Attestations'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Attestations'
	if size := len(b.Attestations); size > 4096 {
		err = ssz.ErrListTooBigFn("BlockBody.Attestations", size, 4096)
		return
	}
	for ii := 0; ii < len(b.Attestations); ii++ {
		if dst, err = b.Attestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlockBody object
func (b *BlockBody) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Attestations'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Attestations'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 168, 4096)
		if err != nil {
			return err
		}
		b.Attestations = make([]SignedVote, num)
		for ii := 0; ii < num; ii++ {
			if err = b.Attestations[ii].UnmarshalSSZ(buf[ii*168 : (ii+1)*168]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockBody object
func (b *BlockBody) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Attestations'
	size += len(b.Attestations) * 168

	return
}

// HashTreeRoot ssz hashes the BlockBody object
func (b *BlockBody) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockBody object with a hasher
func (b *BlockBody) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Attestations'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Attestations))
		if num > 4096 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Attestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4096)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockBody object
func (b *BlockBody) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the Block object
func (b *Block) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the Block object to a target array
func (b *Block) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(84)

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalUint64(dst, b.ProposerIndex)

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	// Field (3) 'StateRoot'
	dst = append(dst, b.StateRoot[:]...)

	// Offset (4) 'Body'
	dst = ssz.WriteOffset(dst, offset)

	// Field (4) 'Body'
	if dst, err = b.Body.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Block object
func (b *Block) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 84 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'Slot'
	b.Slot = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'ProposerIndex'
	b.ProposerIndex = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'ParentRoot'
	copy(b.ParentRoot[:], buf[16:48])

	// Field (3) 'StateRoot'
	copy(b.StateRoot[:], buf[48:80])

	// Offset (4) 'Body'
	if o4 = ssz.ReadOffset(buf[80:84]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 != 84 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'Body'
	{
		buf = tail[o4:]
		if err = b.Body.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Block object
func (b *Block) SizeSSZ() (size int) {
	size = 84

	// Field (4) 'Body'
	size += b.Body.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the Block object
func (b *Block) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the Block object with a hasher
func (b *Block) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(b.ProposerIndex)

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'StateRoot'
	hh.PutBytes(b.StateRoot[:])

	// Field (4) 'Body'
	if err = b.Body.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Block object
func (b *Block) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the SignedBlock object
func (s *SignedBlock) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedBlock object to a target array
func (s *SignedBlock) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(36)

	// Offset (0) 'Message'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (0) 'Message'
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedBlock object
func (s *SignedBlock) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 36 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Message'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 36 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Signature'
	copy(s.Signature[:], buf[4:36])

	// Field (0) 'Message'
	{
		buf = tail[o0:]
		if err = s.Message.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedBlock object
func (s *SignedBlock) SizeSSZ() (size int) {
	size = 36

	// Field (0) 'Message'
	size += s.Message.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the SignedBlock object
func (s *SignedBlock) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedBlock object with a hasher
func (s *SignedBlock) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedBlock object
func (s *SignedBlock) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the State object
func (s *State) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the State object to a target array
func (s *State) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(232)

	// Field (0) 'Config'
	if dst, err = s.Config.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(s.Slot))

	// Field (2) 'LatestBlockHeader'
	if dst, err = s.LatestBlockHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (3) 'LatestJustified'
	if dst, err = s.LatestJustified.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'LatestFinalized'
	if dst, err = s.LatestFinalized.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (5) 'HistoricalBlockHashes'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.HistoricalBlockHashes) * 32

	// Offset (6) 'JustifiedSlots'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.JustifiedSlots)

	// Offset (7) 'JustificationRoots'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.JustificationRoots) * 32

	// Offset (8) 'JustificationValidators'
	dst = ssz.WriteOffset(dst, offset)

	// Field (5) 'HistoricalBlockHashes'
	if size := len(s.HistoricalBlockHashes); size > 262144 {
		err = ssz.ErrListTooBigFn("State.HistoricalBlockHashes", size, 262144)
		return
	}
	for ii := 0; ii < len(s.HistoricalBlockHashes); ii++ {
		dst = append(dst, s.HistoricalBlockHashes[ii][:]...)
	}

	// Field (6) 'JustifiedSlots'
	if size := len(s.JustifiedSlots); size > 32768 {
		err = ssz.ErrBytesLengthFn("State.JustifiedSlots", size, 32768)
		return
	}
	dst = append(dst, s.JustifiedSlots...)

	// Field (7) 'JustificationRoots'
	if size := len(s.JustificationRoots); size > 262144 {
		err = ssz.ErrListTooBigFn("State.JustificationRoots", size, 262144)
		return
	}
	for ii := 0; ii < len(s.JustificationRoots); ii++ {
		dst = append(dst, s.JustificationRoots[ii][:]...)
	}

	// Field (8) 'JustificationValidators'
	if size := len(s.JustificationValidators); size > 134217728 {
		err = ssz.ErrBytesLengthFn("State.JustificationValidators", size, 134217728)
		return
	}
	dst = append(dst, s.JustificationValidators...)

	return
}

// UnmarshalSSZ ssz unmarshals the State object
func (s *State) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 232 {
		return ssz.ErrSize
	}

	tail := buf
	var o5, o6, o7, o8 uint64

	// Field (0) 'Config'
	if err = s.Config.UnmarshalSSZ(buf[0:16]); err != nil {
		return err
	}

	// Field (1) 'Slot'
	s.Slot = Slot(ssz.UnmarshallUint64(buf[16:24]))

	// Field (2) 'LatestBlockHeader'
	if err = s.LatestBlockHeader.UnmarshalSSZ(buf[24:136]); err != nil {
		return err
	}

	// Field (3) 'LatestJustified'
	if err = s.LatestJustified.UnmarshalSSZ(buf[136:176]); err != nil {
		return err
	}

	// Field (4) 'LatestFinalized'
	if err = s.LatestFinalized.UnmarshalSSZ(buf[176:216]); err != nil {
		return err
	}

	// Offset (5) 'HistoricalBlockHashes'
	if o5 = ssz.ReadOffset(buf[216:220]); o5 > size {
		return ssz.ErrOffset
	}

	if o5 != 232 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (6) 'JustifiedSlots'
	if o6 = ssz.ReadOffset(buf[220:224]); o6 > size || o5 > o6 {
		return ssz.ErrOffset
	}

	// Offset (7) 'JustificationRoots'
	if o7 = ssz.ReadOffset(buf[224:228]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Offset (8) 'JustificationValidators'
	if o8 = ssz.ReadOffset(buf[228:232]); o8 > size || o7 > o8 {
		return ssz.ErrOffset
	}

	// Field (5) 'HistoricalBlockHashes'
	{
		buf = tail[o5:o6]
		num, err := ssz.DivideInt2(len(buf), 32, 262144)
		if err != nil {
			return err
		}
		s.HistoricalBlockHashes = make([]Root, num)
		for ii := 0; ii < num; ii++ {
			copy(s.HistoricalBlockHashes[ii][:], buf[ii*32:(ii+1)*32])
		}
	}

	// Field (6) 'JustifiedSlots'
	{
		buf = tail[o6:o7]
		if len(buf) > 32768 {
			return ssz.ErrBytesLength
		}
		if cap(s.JustifiedSlots) == 0 {
			s.JustifiedSlots = make([]byte, 0, len(buf))
		}
		s.JustifiedSlots = append(s.JustifiedSlots, buf...)
	}

	// Field (7) 'JustificationRoots'
	{
		buf = tail[o7:o8]
		num, err := ssz.DivideInt2(len(buf), 32, 262144)
		if err != nil {
			return err
		}
		s.JustificationRoots = make([]Root, num)
		for ii := 0; ii < num; ii++ {
			copy(s.JustificationRoots[ii][:], buf[ii*32:(ii+1)*32])
		}
	}

	// Field (8) 'JustificationValidators'
	{
		buf = tail[o8:]
		if len(buf) > 134217728 {
			return ssz.ErrBytesLength
		}
		if cap(s.JustificationValidators) == 0 {
			s.JustificationValidators = make([]byte, 0, len(buf))
		}
		s.JustificationValidators = append(s.JustificationValidators, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the State object
func (s *State) SizeSSZ() (size int) {
	size = 232

	// Field (5) 'HistoricalBlockHashes'
	size += len(s.HistoricalBlockHashes) * 32

	// Field (6) 'JustifiedSlots'
	size += len(s.JustifiedSlots)

	// Field (7) 'JustificationRoots'
	size += len(s.JustificationRoots) * 32

	// Field (8) 'JustificationValidators'
	size += len(s.JustificationValidators)

	return
}

// HashTreeRoot ssz hashes the State object
func (s *State) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the State object with a hasher
func (s *State) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Config'
	if err = s.Config.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Slot'
	hh.PutUint64(uint64(s.Slot))

	// Field (2) 'LatestBlockHeader'
	if err = s.LatestBlockHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (3) 'LatestJustified'
	if err = s.LatestJustified.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'LatestFinalized'
	if err = s.LatestFinalized.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (5) 'HistoricalBlockHashes'
	{
		if size := len(s.HistoricalBlockHashes); size > 262144 {
			err = ssz.ErrListTooBigFn("State.HistoricalBlockHashes", size, 262144)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.HistoricalBlockHashes {
			hh.Append(i[:])
		}
		numItems := uint64(len(s.HistoricalBlockHashes))
		hh.MerkleizeWithMixin(subIndx, numItems, 262144)
	}

	// Field (6) 'JustifiedSlots'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.JustifiedSlots))
		if byteLen > 32768 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(s.JustifiedSlots)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32768+31)/32)
	}

	// Field (7) 'JustificationRoots'
	{
		if size := len(s.JustificationRoots); size > 262144 {
			err = ssz.ErrListTooBigFn("State.JustificationRoots", size, 262144)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.JustificationRoots {
			hh.Append(i[:])
		}
		numItems := uint64(len(s.JustificationRoots))
		hh.MerkleizeWithMixin(subIndx, numItems, 262144)
	}

	// Field (8) 'JustificationValidators'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.JustificationValidators))
		if byteLen > 134217728 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(s.JustificationValidators)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (134217728+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the State object
func (s *State) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}
